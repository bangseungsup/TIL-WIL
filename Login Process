Client : Postman 요청을 보내면													
																
Server SpringBoot 스프링 boot가 그 클라이언트의 요청을 받아서													
																
Database	H2															
																
로그인 시	로그인여부를 확인하는게 : JWT, JSON W TOKEN											
																
client : Server	Database -> 클라이언트가 회원가입 데이터베이스에 유저 저장											
	id / pw															
																
																
	로그인															
	id/pw	 -> 이 아이디랑 패스워드와 동일한 유저를 찾음											
																
	데이터 x	<-	만약 일치하는게 있으면 데이터를 가지고 온다											
	빈 데이터면 회원 가입을 하지 않은 것이다. 이때는 JWT 토큰 발급 x, exception을 던진다.													
	"회원 가입하세요"													

	데이터를 가져왔는데 : 일치 데이터  O -> 그러면 정상 로그인 처리를 할거야													
	토큰을 발급													
																
		<-	JWT를 유저에게 지급, 이 JWT 에다가 User 정보 일부와 그 서비스를 구현한 직접 spring boot만(server)만 알고 있는 key로 암호화해서													
			유저에게 돌려준다 (response로)								서버만의 signature key'를 만들어서 지급하는데, 개인적으로 다른 key를 발급하는 것이 아니다.					
																
그 토큰을 받은 유저는 그 토큰을 어떻게 사용하고 서버는 어떻게 받아들일 것인가?																
																
토큰을 가지고 있는 유저																
만약에 게시글을 작성요청																
		request														
																
header에서 Auth라는 키로 jwt토큰을 다시 보내																
body 게시글내용																
			토큰 확인법													
			시그니처 키로 복호화 시도													
			복호화가 정상적으로 진행이 되지 않으면 토큰 우리가 발급한거 아니야, 안되면 요청을 팅겨낸다													
			복호화 x 시 -> 로그인을 안했거나, 잘못된 토큰													
			복호화 O 시 -> User 정보 일부가 나올거고, 유저 정보 일부를 가지고 DB에서 유저를 찾아온다.													
																
				아까와 마찬가지로 빈 값이면 예외를 던진다.						<-	유저 정보 일부를 가지고 데이터베이스에서 유저 정보를 가져온다.					
				성공했으면 그때 게시글을 저장한다. 데이터베이스에						 ->	데이터베이스에 게시글 저장					
																
																
게			<-		게시글 저장완료						게시글 저장이 됐다면 그것을 서버에 전달					
					는 서버에서 판단을 해서 클라이언트에 전달											
																
																
																
	1개의 클래스는 1개의 책임만 가져야한다.															
	책임이라 함은 보통 역할															
																
객체지향의	단일 책임 원칙															
																
	Dto는 이것을 따라 하나의 역할을 수행한다					이번 프로젝트 Dto는 requestDto, responseDto, PostrequestDto 총 3개가 필요하다.										
	그래서 requestDto , responseDto															
																
header 부분은 		 @pathvariabe 이런 것으로 가능하기 때문에 별도의 dto가 별도 피료없다														
		 @param														
																
																
access 토큰		만료 시간을 할당할 수 있다.			JWT 토큰을 할당할 떄, 토큰 발급 시점으로부터 1분 후 만료						이런 내용을 넣어서 토큰 발급			1분 있어도 토큰이 사라지진 않는다. 하지만 만료된 토큰이기 떄문에 토큰이 만료됐다는 응답을 줄 것이다.		
		왜 토큰 만료시간을 정하느냐?			토큰은 탈취당할 가능성이 높다. 탈취당했을 경우, 그 토큰을 활용할 가능성을 없애기 위해 만료시켜서 사용이 어렵도록 하기 위해서											
		만료가 다 됐을때 토큰을 다시 발급받기 귀찮으니까 refresh 토큰														
																
refresh토큰		access 토큰을 재발급 받기 위한 토큰, 만료시간이 상대적이 길다.							access토큰을 줄때 refresh 토큰을 같이 준다.							
		클라이언트가 게시글 작성을 위해 access 토큰을 처음 보낼때 refresh 토큰을 같이 보낸다.									access 토큰 만료시, refresh토큰은 만료시간이 더 길기 때문에 (살아있다면) access 토큰을 재생성해서 보내줄때 , 이때 refresh 토큰도 함께 보내준다. 이때 로그인 O, 인증 o 된 상태로					
		* POSTMAN 으로는 두개를 같이 보내는 방법밖에 안된다. 따로따로 보내는 것 불가														
																
																
																
																
																
																
SQL		데이터베이스, RDBMS 관계형 데이터베이스에 접근을해서 데이터를 추출 혹은 삭제, 수정하기위한 언어														
																
																
JPA		JPA는 자바, 스프링에서 사용되는 ORM 기술														
																
																
ORM		스프링부트 서버 내에서 JAVA(JPA)의 메소드를 쓰듯이 (ex; findById, findAll) JPA가 데이터 베이스에 SQL문을 날려준다. SELECT * FROM // 번역을 해주는 역할을 하는게 ORM														
		자바로 메소드를 쓰면 ORM,JPA가 SQL 언어로 DB에 접근할 수 있도록 해준다.														
																
