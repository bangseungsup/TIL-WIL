# Array와 Linkend List

### Array
배열은 정적 자료구조이다. 정적인 자료 구조인만큼 미리 크기를 정해 놓으며, 해당 크기 만큼의 연속된 메모리 주소를 할당 받게 된다.

연속된 메모리 주소를 할당 받고 있기 때문에 데이터가 **인덱스(index)** 라는 것을 가지게 된다. 인덱스를 갖는 다는 것은 **임의 접근이 가능하다는 장점이 있고, 이는 접근과 탐색에 용이**하다.

하지만 크기를 정해 놓았기 때문에 수정하는 것이 불가능하다. 또한 이미 크기를 정해 놓은 터라 해당 배열 크기 이상의 데이터를 저장할 수 없다는 단점이 존재한다.


### Linked List
링크드 리스트는 동적 자료구조이다. 크기가 정해져 있지 않으며, 배열처럼 연속된 메모리 주소를 할당 받지 않는다.

노트(Node)라는 게 존재하며, 그 노드 안에 데이터가 있고, 다음 데이터를 가리키는 주소를 가지고 있다. 이런 형태로 연결되어 이어진 형태이다.

링크드 리스트는 크기를 정해 놓지 않았기 때문에 크기의 제한이 없으며, **데이터의 추가 및 삭제가 자유**롭다는 장점이 있다.

반면에 배얼처럼 연속적인 메모리 주소를 할당 받지 않았기 때문에 **임의로 접근하는 것이 불가능**하다. 그 말인 즉슨 데이터를 탐색할 때 순차적으로 접근해야 한다는 특징이 있다.


| Array | Linked List  |
|:----------|:----------:|
| 정적 자료구조 | 동적 자료구조 |
| 미리 크기를 정해 놓음 | 크기를 정할 필요 없음 |
| 연속된 메모리 주소를 할당 받음 | 연속된 메모리 주소를 할당 받지 않음 |
| 접근/탐색 용이 | 추가/삭제 용이 |
| index 존재 | Node 존재 |

#### 용도
- 배열 : 빠른 접근이 요구되고, 데이터의 삽입과 삭제가 적을 때 사용
- 연결리스트 : 삽입과 삭제 연산이 잦고, 검색 빈도가 적을 때 사용


#### 시간복잡도
##### Array
- index를 가지고 있기 때문에 탐색은 O(1)의 시간 복잡도
- 삽입의 경우, 맨 뒤는 O(1), 맨 뒤가 아닌 나머지는 O(n) : 순서가 정해져 있기 때문에 시간 복잡도는 변화

##### Linked List
- 추가 삭제가 용이한 Linked List는 삽입은 맨 앞일 경우 O(1), 맨 앞이 아닌 나머지는 O(n)
- 배열과 반대로 탐색은 O(n)의 시간 복잡도를 가짐 (순차적으로 검색해야 하기 때문에)

#### 이중 연결 리스트(Doubly Linked List)
- 이중 연결 리스트는 연결 리스트와 다르게 전/후로 탐색이 가능한 구조이다.
- 즉, 단순 연결 리스트의 노드는 데이터와 다음 노드의 주소를 저장한다면, 이중 연결 리스트의 노드는 데이터, 이전 노드의 주소와 다음 노드의 주소를 저장하게 된다.
- 장점 : 단순 연결 리스트에선는 최악의 경우 n번의 탐색을 해야하지만, 이중 연결 리스트에서는 얻고자 하는 데이터의 위치가 tail에 가깝다면 tail에서부터 역방향으로 탐색이 가능하기 때문에 탐색 시간을 줄일 수 있다.

#### 원형 연결 리스트(Circular Linked List)
- 원형 연결 리스트는 단순 연결 리스트의 마지막 노드가 null이 아닌, 처음 노드를 가리키는 구조이다.
- 즉, head에서부터 순회를 반복적으로 진행하다보면 다시 처음으로 돌아오는 구조이다.
- 이중 연결 리스트(Doubly Linked List)도 마지막 노드가 청므 노드를 가리키는 구조가 되면, 이중 원형 연결 리스트(Circular Linked List)라고 한다.
